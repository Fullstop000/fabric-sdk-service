/*
 * This Java source file was generated by the Gradle 'init' task.
 */

import com.yunphant.coin.YunphantHFClient;
import com.yunphant.coin.common.FabricConfigHelper;
import com.yunphant.coin.common.configbeans.FabricConfig;
import com.yunphant.coin.models.CoinTransaction;
import com.yunphant.coin.sample.SampleOrg;
import com.yunphant.coin.utils.ChainCodeUtils;
import com.yunphant.coin.utils.SDKUtils;
import org.hyperledger.fabric.protos.peer.Query;
import org.hyperledger.fabric.sdk.*;
import org.hyperledger.fabric.sdk.exception.InvalidArgumentException;
import org.hyperledger.fabric.sdk.exception.ProposalException;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;

import static java.nio.charset.StandardCharsets.UTF_8;

/**
 * The type App test.
 */
public class AppTest {

    private static final Logger LOGGER = LoggerFactory.getLogger(AppTest.class);
    private static final long PROPOSAL_WAIT_TIME = 10000L;
    private HFClient client ;

    private ChaincodeID testCCId;
    private FabricConfig config ;
    private static final String CHANNEL_NAME = "coinchannel";

    /**
     * Init.
     *
     * @throws Exception the exception
     */
    @Before
    public void init() throws Exception {
        client = YunphantHFClient.getInstance().getClient();
        testCCId = ChaincodeID.newBuilder().setName("yunphantCoinCC").setPath("yunphant/coin").setVersion("0.1").build();
        config = FabricConfigHelper.getInstance().getConfig();
    }

    /**
     * Test create channel.
     *
     * @throws Exception the exception
     */
    @Test
    public void testCreateChannel() throws Exception {
        Map<String,SampleOrg> orgMap = SDKUtils.getOrgsFromConfig(client);
        Channel channel = SDKUtils.constructChannel(false,CHANNEL_NAME,client,orgMap.values().iterator().next());
        Assert.assertNotNull(channel);
    }

    /**
     * Test construct channel.
     *
     * @throws Exception the exception
     */
    @Test
    public void testConstructChannel() throws Exception {
        Map<String,SampleOrg> orgMap = SDKUtils.getOrgsFromConfig(client);
        SampleOrg org = orgMap.get("Org0");
        Channel channel = SDKUtils.constructChannel(true,CHANNEL_NAME,client,org);
        Assert.assertNotNull(channel);
    }

    /**
     * Test join peers.
     *
     * @throws Exception the exception
     */
    @Test
    public void testJoinPeers() throws Exception {
        Map<String,SampleOrg> orgMap = SDKUtils.getOrgsFromConfig(client);
        SDKUtils.joinAllPeers(config.getChannelName(),client,orgMap);
    }

    /**
     * Test send install proposal.
     *
     * @throws Exception the exception
     */
    @Test
    public void testSendInstallProposal() throws Exception {
        Map<String,SampleOrg> orgMap = SDKUtils.getOrgsFromConfig(client);
//        SDKUtils.joinAllPeers(config.getChannelName(),client,orgMap);
        for (Map.Entry<String, SampleOrg> entry : orgMap.entrySet()) {
            SampleOrg org = entry.getValue();
            client.setUserContext(org.getPeerAdmin());
            label1:for (Peer peer : org.getPeers()) {
                List<Query.ChaincodeInfo> chainCodeInfo = client.queryInstalledChaincodes(peer);
                for (Query.ChaincodeInfo chaincodeInfo : chainCodeInfo) {
                    if (testCCId.getVersion().equals(chaincodeInfo.getVersion())&&testCCId.getName().equals(chaincodeInfo.getName())&&testCCId.getPath().equals(chaincodeInfo.getPath())){
                        LOGGER.warn(" ******** ChainCode has already been installed in : "+ peer.getName());
                        continue label1;
                    }
                }
                Collection<ProposalResponse> responses = client.sendInstallProposal(
                        ChainCodeUtils.demoCCInstallProposal(client,testCCId), Collections.singleton(peer));
                responses.forEach(response -> System.out.println(response.getMessage()));
            }

        }


    }

    /**
     * Test instantiate proposal.
     *
     * @throws Exception the exception
     */
    @Test
    public void testInstantiateProposal() throws Exception {
        Map<String,SampleOrg> orgMap = SDKUtils.getOrgsFromConfig(client);
        SampleOrg org = orgMap.values().iterator().next();
        Channel channel = SDKUtils.constructChannel(true,CHANNEL_NAME,client,org);
        for (Peer peer : org.getPeers()) {
            channel.addPeer(peer);
        }
        InstantiateProposalRequest request = ChainCodeUtils.demoCCInstantiateProposal(client,testCCId);
        request.setArgs(new String[] {"a"});
        channel.sendTransaction(channel.sendInstantiationProposal(request,org.getPeers())).thenApply(transactionEvent->{
            Assert.assertTrue(transactionEvent.isValid());
            try {
                TransactionInfo txInfo = channel.queryTransactionByID(transactionEvent.getTransactionID());
                Assert.assertNotNull(txInfo);
            } catch (ProposalException | InvalidArgumentException e) {
                Assert.fail(e.getMessage());
            }
            return null;
        });
//        SampleOrg org = SDKUtils.getSampleOrg(client);
//        Channel channel = SDKUtils.constructChannel(true,CHANNEL_NAME,client,org);
//
//        org.getPeers().forEach(peer -> {
//            try {
//                channel.addPeer(peer);
//            } catch (InvalidArgumentException e) {
//                Assert.fail();
//            }
//        });

    }
    @Test
    public void testInvokeChainCode_createAccount() throws Exception{
        Map<String,SampleOrg> orgMap = SDKUtils.getOrgsFromConfig(client);
        SampleOrg org = orgMap.values().iterator().next();
        Channel channel = SDKUtils.constructChannel(true,CHANNEL_NAME,client,org);
        for (Peer peer : org.getPeers()) {
            channel.addPeer(peer);
        }
        TransactionProposalRequest request = client.newTransactionProposalRequest();
        request.setChaincodeID(testCCId);
        request.setFcn("createAccount");
        request.setArgs(new String[]{"{\"userID\":99999,\"balance\":1000}"});
        request.setProposalWaitTime(PROPOSAL_WAIT_TIME);
        Map<String, byte[]> map = new HashMap<>();
        map.put("HyperLedgerFabric", "TransactionProposalRequest:JavaSDK".getBytes(UTF_8)); //Just some extra junk in transient map
        map.put("method", "TransactionProposalRequest".getBytes(UTF_8)); // ditto
        request.setTransientMap(map);
        Collection<ProposalResponse> responses = channel.sendTransactionProposal(request,org.getPeers());
        responses.forEach(response -> {
            if (response.getStatus() != ProposalResponse.Status.SUCCESS){
                Assert.fail("Fail to send transaction. ");
            }
            LOGGER.info(response.getProposalResponse().getResponse().getPayload().toStringUtf8());
        });
        channel.sendTransaction(responses).thenApply(transactionEvent -> {
            try {
                if (transactionEvent.isValid()){
                    TransactionInfo txInfo = channel.queryTransactionByID(transactionEvent.getTransactionID());
                    Assert.assertNotNull(txInfo);
                }else{
                    Assert.fail();
                }

            } catch (ProposalException | InvalidArgumentException e) {
                Assert.fail();
            }
            return null;
        });

        TransactionProposalRequest request2 = client.newTransactionProposalRequest();
        request2.setChaincodeID(testCCId);
        request2.setFcn("createAccount");
        request2.setArgs(new String[]{"{\"userID\":66666,\"balance\":500}"});
        request.setProposalWaitTime(PROPOSAL_WAIT_TIME);
        Map<String, byte[]> map2 = new HashMap<>();
        map2.put("HyperLedgerFabric", "TransactionProposalRequest:JavaSDK".getBytes(UTF_8)); //Just some extra junk in transient map
        map2.put("method", "TransactionProposalRequest".getBytes(UTF_8)); // ditto
        request2.setTransientMap(map2);

        responses = channel.sendTransactionProposal(request2,org.getPeers());
        responses.forEach(response -> {
            if (response.getStatus() != ProposalResponse.Status.SUCCESS){
                Assert.fail("Fail to send transaction. ");
            }
            LOGGER.info(response.getProposalResponse().getResponse().getPayload().toStringUtf8());
        });
        channel.sendTransaction(responses).thenApply(transactionEvent -> {
            try {
                if (transactionEvent.isValid()){
                    TransactionInfo txInfo = channel.queryTransactionByID(transactionEvent.getTransactionID());
                    Assert.assertNotNull(txInfo);
                }else{
                    Assert.fail();
                }

            } catch (ProposalException | InvalidArgumentException e) {
                Assert.fail();
            }
            return null;
        });
    }
    /**
     * Test invoke chain code add coin transaction.
     *
     * @throws Exception the exception
     */
    @Test
    public void testInvokeChainCode_addCoinTransaction() throws Exception {
        Map<String,SampleOrg> orgMap = SDKUtils.getOrgsFromConfig(client);
        SampleOrg org = orgMap.values().iterator().next();
        Channel channel = SDKUtils.constructChannel(true,CHANNEL_NAME,client,org);
        org.getPeers().forEach(peer -> {
            try {
                channel.addPeer(peer);
            } catch (InvalidArgumentException e) {
                Assert.fail();
            }
        });
        TransactionProposalRequest request = client.newTransactionProposalRequest();
        request.setChaincodeID(testCCId);
        request.setFcn("addCoinTransaction");
        CoinTransaction transaction = new CoinTransaction();
        transaction.setReceiver(66666);
        transaction.setSender(99999);
        transaction.setTimestamp(System.currentTimeMillis());
        transaction.setType("test");
        transaction.setAmount(300);
        request.setArgs(new String[]{transaction.toJsonStr()});
        request.setProposalWaitTime(PROPOSAL_WAIT_TIME);
        Map<String, byte[]> map = new HashMap<>();
        map.put("HyperLedgerFabric", "TransactionProposalRequest:JavaSDK".getBytes(UTF_8)); //Just some extra junk in transient map
        map.put("method", "TransactionProposalRequest".getBytes(UTF_8)); // ditto
//        map.put("result", ":)".getBytes(UTF_8));  // This should be returned see chaincode why.
//        map.put("event", "!".getBytes(UTF_8));  //This should trigger an event see chaincode why.
        request.setTransientMap(map);
        Collection<ProposalResponse> responses = channel.sendTransactionProposal(request,Collections.singleton(channel.getPeers().iterator().next()));
        responses.forEach(response -> {
            if (response.getStatus() != ProposalResponse.Status.SUCCESS){
                Assert.fail("Fail to send transaction. ");
            }
            LOGGER.info(response.getProposalResponse().getResponse().getPayload().toStringUtf8());
        });
        channel.sendTransaction(responses).thenApply(transactionEvent -> {
            try {
                if (transactionEvent.isValid()){
                    TransactionInfo txInfo = channel.queryTransactionByID(transactionEvent.getTransactionID());
                    Assert.assertNotNull(txInfo);
                }else{
                    Assert.fail();
                }

            } catch (ProposalException | InvalidArgumentException e) {
                Assert.fail();
            }
            return null;
        });
    }

    @Test
    public void testInvokeChainCode_queryBalance() throws Exception {
        Map<String,SampleOrg> orgMap = SDKUtils.getOrgsFromConfig(client);
        SampleOrg org = orgMap.values().iterator().next();
        Channel channel = SDKUtils.constructChannel(true,CHANNEL_NAME,client,org);
        org.getPeers().forEach(peer -> {
            try {
                channel.addPeer(peer);
            } catch (InvalidArgumentException e) {
                Assert.fail();
            }
        });
        TransactionProposalRequest request = client.newTransactionProposalRequest();
        request.setChaincodeID(testCCId);
        request.setFcn("queryBalance");
        request.setArgs(new String[]{"66666"});
        request.setProposalWaitTime(PROPOSAL_WAIT_TIME);
        Map<String, byte[]> map = new HashMap<>();
        map.put("HyperLedgerFabric", "TransactionProposalRequest:JavaSDK".getBytes(UTF_8)); //Just some extra junk in transient map
        map.put("method", "TransactionProposalRequest".getBytes(UTF_8)); // ditto

        request.setTransientMap(map);
        channel.sendTransactionProposal(request,Collections.singleton(channel.getPeers().iterator().next())).forEach(response -> {
            LOGGER.info(response.getProposalResponse().getResponse().getPayload().toStringUtf8());
        });

    }
    /**
     * Test invoke chain code query.
     *
     * @throws Exception the exception
     */
    @Test
    public void testInvokeChainCode_queryTransaction() throws Exception {
        String queryStr = "{ \"selector\": {\"type\":\"test\"}}";
        Map<String,SampleOrg> orgMap = SDKUtils.getOrgsFromConfig(client);
        SampleOrg org = orgMap.values().iterator().next();
        Channel channel = SDKUtils.constructChannel(true,CHANNEL_NAME,client,org);
        org.getPeers().forEach(peer -> {
            try {
                channel.addPeer(peer);
            } catch (InvalidArgumentException e) {
                Assert.fail();
            }
        });
        TransactionProposalRequest request = client.newTransactionProposalRequest();
        request.setChaincodeID(testCCId);
        request.setFcn("queryTransactionRecord");
        request.setArgs(new String[]{queryStr});
        request.setProposalWaitTime(PROPOSAL_WAIT_TIME);
        Map<String, byte[]> map = new HashMap<>();
        map.put("HyperLedgerFabric", "TransactionProposalRequest:JavaSDK".getBytes(UTF_8)); //Just some extra junk in transient map
        map.put("method", "TransactionProposalRequest".getBytes(UTF_8)); // ditto

        request.setTransientMap(map);
        channel.sendTransactionProposal(request,Collections.singleton(channel.getPeers().iterator().next())).forEach(response -> {
            LOGGER.info(response.getProposalResponse().getResponse().getPayload().toStringUtf8());
        });
    }
}
