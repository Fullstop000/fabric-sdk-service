/*
 * This Java source file was generated by the Gradle 'init' task.
 */

import com.yunphant.coin.TestHFClient;
import com.yunphant.coin.models.CoinTransaction;
import com.yunphant.coin.sample.SampleOrg;
import com.yunphant.coin.utils.ChainCodeUtils;
import com.yunphant.coin.utils.SDKUtils;
import org.hyperledger.fabric.protos.peer.Query;
import org.hyperledger.fabric.sdk.*;
import org.hyperledger.fabric.sdk.exception.InvalidArgumentException;
import org.hyperledger.fabric.sdk.exception.ProposalException;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;

import static java.nio.charset.StandardCharsets.UTF_8;

public class AppTest {

    private static final Logger LOGGER = LoggerFactory.getLogger(AppTest.class);
    private static final long PROPOSAL_WAIT_TIME = 10000L;
    private HFClient client ;

    private ChaincodeID testCCId;

    @Before
    public void init() throws Exception {
        client = TestHFClient.getInstance().getClient();
        testCCId = ChaincodeID.newBuilder().setName("yunphantCoinCC").setPath("yunphant/coin").setVersion("0.1").build();
    }

    @Test
    public void testHFClient() throws Exception {
        // Test peer query
        Peer peer1 = client.newPeer("peer1","grpc://localhost:7051");
//        Peer peer2 = client.newPeer("peer2","grpc://127.0.0.1:7051");
        Set<String> channelSet = client.queryChannels(peer1);
        LOGGER.info(channelSet.iterator().next());
        Assert.assertTrue(channelSet.contains("mychannel"));
    }
    @Test
    public void testCreateChannel() throws Exception {
        SampleOrg org = SDKUtils.getSampleOrg(client);
        Channel channel = SDKUtils.constructChannel(false,"mychannel",client,org);
        Assert.assertNotNull(channel);
    }
    @Test
    public void testConstructChannel() throws Exception {
        SampleOrg org = SDKUtils.getSampleOrg(client);
        Channel channel = SDKUtils.constructChannel(true,"mychannel",client,org);
        Assert.assertNotNull(channel);
    }

    @Test
    public void testJoinPeers() throws Exception {
        SampleOrg org = SDKUtils.getSampleOrg(client);
        Channel channel = SDKUtils.constructChannel(true,"mychannel",client,org);
        SDKUtils.joinPeers(org.getPeers(),channel,client);
    }

    @Test
    public void testSendInstallProposal() throws Exception {
        Peer peer1 = client.newPeer("peer1","grpc://localhost:7051");
        List<Query.ChaincodeInfo> chainCodeInfo = client.queryInstalledChaincodes(peer1);
        for (Query.ChaincodeInfo chaincodeInfo : chainCodeInfo) {
            if (testCCId.getVersion().equals(chaincodeInfo.getVersion())&&testCCId.getName().equals(chaincodeInfo.getName())&&testCCId.getPath().equals(chaincodeInfo.getPath())){
                Assert.fail("ChainCode has already been installed");
            }
        }
        Collection<ProposalResponse> responses = client.sendInstallProposal(ChainCodeUtils.demoCCInstallProposal(client,testCCId),
                Arrays.asList(peer1,client.newPeer("peer2", "grpc://localhost:8051")));
        responses.forEach(response -> System.out.println(response.getMessage()));
    }
    @Test
    public void testGetOrg() throws Exception {
        SampleOrg org = SDKUtils.getSampleOrg(client);
    }
    @Test
    public void testInstantiateProposal() throws Exception {
        SampleOrg org = SDKUtils.getSampleOrg(client);
        Channel channel = SDKUtils.constructChannel(true,"mychannel",client,org);

        org.getPeers().forEach(peer -> {
            try {
                channel.addPeer(peer);
            } catch (InvalidArgumentException e) {
                Assert.fail();
            }
        });
        InstantiateProposalRequest request = ChainCodeUtils.demoCCInstantiateProposal(client,testCCId);
        request.setArgs(new String[] {"a"});
        channel.sendTransaction(channel.sendInstantiationProposal(request)).thenApply(transactionEvent->{
            Assert.assertTrue(transactionEvent.isValid());
            try {
                TransactionInfo txInfo = channel.queryTransactionByID(transactionEvent.getTransactionID());
                Assert.assertNotNull(txInfo);
            } catch (ProposalException | InvalidArgumentException e) {
                Assert.fail();
            }
            return null;
        });
    }

    @Test
    public void testInvokeChainCode_addCoinTransaction() throws Exception {
        SampleOrg org = SDKUtils.getSampleOrg(client);
        Channel channel = SDKUtils.constructChannel(true,"mychannel",client,org);
//       TransactionRequest is  A base transaction request common for InstallProposalRequest,trRequest, and QueryRequest
        org.getPeers().forEach(peer -> {
            try {
                channel.addPeer(peer);
            } catch (InvalidArgumentException e) {
                Assert.fail();
            }
        });
        TransactionProposalRequest request = client.newTransactionProposalRequest();
        request.setChaincodeID(testCCId);
        request.setFcn("addCoinTransaction");
        request.setArgs(new String[]{CoinTransaction.genRandom().toJsonStr()});
        request.setProposalWaitTime(PROPOSAL_WAIT_TIME);
        Map<String, byte[]> map = new HashMap<>();
        map.put("HyperLedgerFabric", "TransactionProposalRequest:JavaSDK".getBytes(UTF_8)); //Just some extra junk in transient map
        map.put("method", "TransactionProposalRequest".getBytes(UTF_8)); // ditto
//        map.put("result", ":)".getBytes(UTF_8));  // This should be returned see chaincode why.
//        map.put("event", "!".getBytes(UTF_8));  //This should trigger an event see chaincode why.
        request.setTransientMap(map);
        Collection<ProposalResponse> responses = channel.sendTransactionProposal(request,channel.getPeers());
        responses.forEach(response -> {
            if (response.getStatus() != ProposalResponse.Status.SUCCESS){
                Assert.fail("Fail to send transaction. ");
            }
            LOGGER.info(response.getProposalResponse().getResponse().getPayload().toStringUtf8());
        });
        channel.sendTransaction(responses).thenApply(transactionEvent -> {
            try {
                if (transactionEvent.isValid()){
                    TransactionInfo txInfo = channel.queryTransactionByID(transactionEvent.getTransactionID());
                    Assert.assertNotNull(txInfo);
                }else{
                    Assert.fail();
                }

            } catch (ProposalException | InvalidArgumentException e) {
                Assert.fail();
            }
            return null;
        });
    }
    @Test
    public void testInvokeChainCode_query() throws Exception {
        String queryStr = "{ \"selector\": {\"type\":{\"$gt\":null}}}";
        SampleOrg org = SDKUtils.getSampleOrg(client);
        Channel channel = SDKUtils.constructChannel(true,"mychannel",client,org);
        org.getPeers().forEach(peer -> {
            try {
                channel.addPeer(peer);
            } catch (InvalidArgumentException e) {
                Assert.fail();
            }
        });
        TransactionProposalRequest request = client.newTransactionProposalRequest();
        request.setChaincodeID(testCCId);
        request.setFcn("query");
        request.setArgs(new String[]{queryStr});
        request.setProposalWaitTime(PROPOSAL_WAIT_TIME);
        Map<String, byte[]> map = new HashMap<>();
        map.put("HyperLedgerFabric", "TransactionProposalRequest:JavaSDK".getBytes(UTF_8)); //Just some extra junk in transient map
        map.put("method", "TransactionProposalRequest".getBytes(UTF_8)); // ditto

        request.setTransientMap(map);
        channel.sendTransactionProposal(request,Collections.singleton(channel.getPeers().iterator().next())).forEach(response -> {
            LOGGER.info(response.getProposalResponse().getResponse().getPayload().toStringUtf8());
        });
    }
}
